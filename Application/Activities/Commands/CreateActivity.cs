using System;
using Application.Activities.DTOs;
using AutoMapper;
using Domain;
using FluentValidation;
using MediatR;
using Persistence;

namespace Application.Activities.Commands;

public class CreateActivity
{
    // returns string id
    // IRequest has a contract (what), it expects a response of type string.
    public class Command : IRequest<string>
    {
        // receives ActivityDto from ActivitiesController.
        public required CreateActivityDto ActivityDto { get; set; }
    }

    // This Handler handles requests of type CreateActivity.Command.
    // DI container will injects AppDbContext, IMapper by checking Program.cs.
    // Interface IMapper's contract (what) is it has to map source object to destination object.
    // The contract (What) of IRequestHandler<Command, string> is it processes a request (Command) and product a string response.
    public class Handler(AppDbContext context, IMapper mapper) : IRequestHandler<Command, string>
    {
        public async Task<string> Handle(Command request, CancellationToken cancellationToken)
        {
            // <Activity> is the destination. (request.ActivityDto) is the source.
            // DI container injects concrete mapper instance (how), which has been configured to use CreateMap<CreateActivityDto, Activity>() (defined in MappingProfiles.cs).
            // to map request.ActivityDto object from ActivitiesController to create a new instance of Activity entity from Domain Layer.
            // Handler just needs to know Map<Activity>(request.ActivityDto) fulfills Interface IMapper's contract, then passes data to concrete instance mapper.Map().
            var activity = mapper.Map<Activity>(request.ActivityDto);

            // not accessing the database to get value generated by the database, dont use AddAsync.
            // activity holds new Activity object from the domain layer populated by ActivityDto.
            context.Activities.Add(activity);

            // .Add() doesn't immediately write to the database, it tells EF's DbContext to mark the request.Activity object in an "Added" state.
            // SaveChangesAsync makes EF execute SQL query to add request.Activity.
            await context.SaveChangesAsync(cancellationToken);

            // After SaveChangesAsync completes, EF update the request.Activity with Id generated by the database.
            // return Activity Id to use in the client side.
            return activity.Id;
        }
    }
}
